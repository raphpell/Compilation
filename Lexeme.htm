<html>
	<head>
		<title>Lexèmes</title>
		<style>
CODE, PRE {
	background: #FFE;
	border: 1px solid #DDD;
	box-shadow: 0 0 .5em #ccc;
	color: #000;
	font-weight: bold;
	padding: 0 .5em;
	}
PRE {
	font-size: 1.2em;
	padding: 1em;
	}
SECTION {
	margin: .5em;
	}
		</style>
	</head>
<body>

<a href="index.htm">Index</a>
<h1>Lexèmes: structure de données.</h1>
<p>Les lexèmes sont des unités lexicales ou syntaxiques (mots, phrases...).</p>
<p>
	Il faut pouvoir former avec les lexèmes un <b>arbre de données</b>.<br>
	Pour cela, la fonction globale <code>Lexeme</code>  nous retourne un objet pouvant réaliser cette tâche.
</p>

<p><b>NB</b>: <cite>
	La création des lexèmes et les opérations réalisées dessus <a href="Lexeme.comparaison.htm">prennent du temps</a> !
</cite></p>

<section><h2>Syntaxe</h2>
	<pre>var oNode = Lexeme ( oLexeme )</pre>
</section>
<section><h2>Argument</h2>
	<p>Elle prend en argument l'objet <code>oLexeme</code> issu d'une analyse.</p>
	<section><h3>Exemple</h3>
		<p>Pour l'analyse lexicale, il est de la forme :</p>
<pre>
oLexeme={
	token:'INCREMENT_OPERATOR', // nom du token (renommé si défini)
	value:'++',	// valeur du token, NB: un parent n'a pas de valeur
	css:'operator',	// classe css...
	rule:'JS',	// Syntaxe qui à créé le lexème
    // Position dans la source
	index:12, 	// index du premier caractère
	lineStart:2,	// ligne du premier caractère
	lineEnd:2, 	// ligne du dernier caractère
    // Propriétés parfois présentent
	bParent:true,		// Indique si il s'agit d'un lexème parent
	bParentLimit:true,	// Indique si il s'agit d'une limite d'un parent
	bRescan:true		// Indique si il s'agit d'un lexème parent issu d'un double scannage
	}
</pre>
		<p>Pour l'analyse syntaxique il est à définir...</p>
	</section>
</section>
<section><h2>Valeur retournée</h2>
	<p>
		Elle retourne un objet devant pouvoir former une structure arborescente.<br>
		A cet objet est ajouté l'attribut <code>oValue</code>, affecté avec la valeur <code>oLexeme</code>: <code>oNode.oValue === oLexeme</code>.
	</p>
	<p>L'objet retourné est au choix :</p>
	<ul>
		<li><b>Un HTMLElement</b>
			<ul>
				<li style="color:green;">Permet d'afficher facilement le résultat de l'analyse.</li>
				<li style="color:green;">Pas de fichier supplémentaire à charger.</li>
				<li>Pour l'instant mon éditeur de texte est plus rapide avec !</li>
			</ul><br></li>
		<li><b>Un objet JavaScript implémentant l'interface des HTMLElement</b>
			<ul>
				<li style="color:red;">Pas forcement plus performant: création plus rapide, méthodes plus lentes... .</li>
			</ul></li>
	</ul>
	<section><h3>Interface requise</h3>
		<ul>
			<li>appendChild ( eNode )</li>
			<li>hasChildNodes ()</li>
			<li>insertBefore ( eNode, eNextSibling )</li>
			<li>removeChild ( eChild )</li>
			<li>firstChild</li>
			<li>lastChild</li>
			<li>nextSibling</li>
			<li>parentNode</li>
			<li>previousSibling</li>
			<li>... voir getElementsByTagName ( sTagName )</li>
		</ul>
	</section>
</section>
<section><h2>Exemple de fonction</h2>
<pre>
var Lexeme =function( o ){
	var m = document.createElement( o.token )
	m.oValue = o
	m.className = o.css
	m.title = o.token
	if( o.value ) m.innerHTML = o.value
	// ou if( ! o.bParent ) m.innerHTML = o.value
	return m
	}
</pre>
</section>

<script src="js/framework.js"></script>
<script src="js/lexer.automaton.js"></script>
<script src="js/lexer.automaton.modules.js"></script>
<link rel="stylesheet" type="text/css" href="css/syntaxes.css">
<script>
function colorize ( e ){
	var sText = e.innerHTML
	e.innerHTML = ''
	e.appendChild( AutomatonLexer( sText, 'JS' ))
	}
var Lexeme =function( o ){
	var m = document.createElement( o.token )
	m.oValue = o
	m.className = o.css
	m.title = o.token
	if( o.value ) m.innerHTML = o.value
	return m
	}
	
var aPRE = document.getElementsByTagName('PRE')
for(var i=0, ni=aPRE.length; i<ni; i++ ) colorize( aPRE.item(i))
var aCODE = document.getElementsByTagName('CODE')
for(var i=0, ni=aCODE.length; i<ni; i++ ) colorize( aCODE.item(i))

</script>

</body>
</html>