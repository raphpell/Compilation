<html>
	<head>
		<title>Performance du Lexer</title>
		<style>
UL {
	list-style-position: inside;
	padding: 0 1em;
	margin: 1em 0;
	}
LI {
	padding: 0 1em;
	}
.automatonLexer {
	background: #FEA;
	margin: .5em 0;
	padding: .5em 1em;
	}
.regexpMultipleLexer {
	background: #DFD;
	margin: .5em 0;
	padding: .5em 1em;
	}
.regexpOneLexer {
	background: #FDD;
	margin: .5em 0;
	padding: .5em 1em;
	}
		</style>
	</head>
	<body>
<a href="index.htm">Index</a>

<h1>Performance du Lexer</h1>
<p>La difficulté est de trouver où le temps est perdu.</p>


<h2>Mes lexers</h2>
<p>
	Mes Lexer sont rapides au niveau de la <a href="131_Lexer.byStep.htm">lecture des tokens</a>, 
	mais cette vitesse dépend du <a href="#LexerNode">LexerNode</a> utilisé.<br>
	Voici la liste de <a href="133_Lexer.comparison.htm">mes Lexer</a> classés par préférence:
</p>
<ul>
	<li class="automatonLexer"><b>Automaton Lexer</b>
		<ul>
			<li>Le texte est parcourue une et une seule fois et voila...</li>
			<li>Le plus long token trouvé est toujours retourné.</li>
			<li>Il peut aussi:
				<ol>
					<li>parcourir une liste d'automates.</li>
					<li>rescanner un token trouvé.</li>
					<li>réaliser une <a href="134_Lexer.update.htm">analyse partielle</a></li>
				</ol>
			</li>
		</ul></li>
	<li class="regexpMultipleLexer"><b>Multiple RegExp Lexer</b>
		<ul>
			<li>Il parcourt une liste d'ER une à une tant que tout le texte n'est pas parcouru.</li>
			<li>Il vaut mieux quelle soit classée par ordre d'apparition courante.</li>
			<li>Première arrivée, première servie.</li>
			<li>Un ordre des ER est requis: mots clés avant identifiant, etc...</li>
			<li>Lexer le plus rapide...</li>
		</ul></li>
	<li class="regexpOneLexer"><b>"1 RegExp" Lexer</b> <sup style="color:red;">A éviter!</sup>
		<ul>
			<li>Une seule grande expression régulière est créée pour parcourir le texte.</li>
			<li>Le défaut: quand un mot est trouvé il faut déterminé son type.</li>
			<li>Pour cela il faut parcourir toutes les expressions régulières (celles utilisées pour créer la grande).</li>
			<li>Les expressions régulières utilisées pour créer la grande ont une organisation spéciale... (voir Multiple RegExp Lexer)</li>
		</ul></li>
</ul>
<p style="margin-bottom:0;">
	Ils réalisent tous une analyse sur <a href="132_Lexer.level.html">plusieurs niveaux</a>: un <i>arbre lexicale</i> est créé.<br>
	Normalement:
</p>
<ul style="margin-top:0;">
	<li>Seule une liste de token devrait-être générée</li>
	<li>L'<a href="200_AnalyseSyntaxique.htm">analyse syntaxique</a> devrait-être faite en parallèle (voir <a href="210_Parser.html">grammaire</a>).</li>
</ul>

<a name="LexerNode"></a>
<h2>La fonction LexerNode</h2>
<p>
	Elle influe La performance des lexers car la création des tokens prend du temps ! 
	Plus l'objet est gros, plus le temps mis pour le créer est long.<br>
	Elle retourne un objet affecté avec un attribut nommé <var>oValue</var> (valeurs du token). <br>
	Cet objet est soit :
</p>
<ul style="margin: 0 0 2em 2em;">
	<li><b>Un élément HTML</b>
		<ul>
			<li>Plus lent.</li>
			<li>Permet d'afficher facilement le résultat de l'analyse.</li>
			<li>Pour l'instant mon éditeur créé avec le Lexer Automaton est plus rapide avec (Il utilise pleinement les possibilités HTML !).</li>
		</ul></li>
	
	<li><b>Un objet JavaScript implémentant l'interface des éléments HTML</b>
		<ul>
			<li>Plus rapide (interface implémentée réduite).</li>
		</ul></li>
</ul>


	</body>
</html>