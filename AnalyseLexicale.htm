<html>
	<head>
		<title>Analyse lexicale</title>
		<style>
.myNode {
	border:1px solid #CCC;
	display:inline-block;
	margin: 2px;
	padding: 2px;
	white-space: pre;
	}
.brut
	{ background: blue; }
.undefined
	{ background: yellow; }

.tab		{ background: LIGHTBLUE !important; }
.space		{ background: LIGHTGREEN !important; }
.linefeed	{ background: ORANGE !important; }
#eResult {
	display: inline;
	vertical-align: top;
	}
		</style>
	</head>
	<body>
<a href="index.htm">Index</a>

<h1>Analyse lexicale</h1>
<p>
	La machine réalisant cette tâche est nommée <b>lexer</b> dans cette application.<br>
	Autres noms possibles:  <i>scanneur</i>, <i>lexeur</i> ou <i>analyseur lexical</i>.
</p>


<h2>Principes</h2>
<p>
	Le lexer parcours un texte source caractère/caractère et le transforme en 
	<a href="Lexers.performance.readToken.htm">liste de lexèmes</a> (ayant comme attributs: type, index, valeur, ...).<br>
	Essayer de changer le texte ci-dessous :
</p>
<textarea id="eTextScanned" type="text">Le texte source.
	
FIN.</textarea>
<div id="eResult">...</div>
<p>Chaque type de lexème est défini à l'aide d'une <a href="src/regexp/syntax.htm">ER</a>.</p>
<p>
	Le lexer utilise <b>directement les ER</b> ou des <b>AFD issus de ces ER</b>. 
	Les <a href="Lexers.performance.scan.htm">performances</a> sont sensiblement équivalente.
	<br>
	Mais la dernière solution est préférable car elle nous laissent plus possibilités en programmation
	<br>
	L'<a href="LexerAutomaton.incremental.htm">analyse partielle</a> n'est pas forcement un exemple... 
	elle n'est pas implémenté pour le lexer à ER pour qu'il puisse rester le plus performant.
</p>


<h2>Considérations techniques</h2>


<h3>Les Expressions Régulières</h3>
<p>
	Pour simplifier significativement la création des ER,
	les lexers retourne un 'arbre lexical' à la place d'une liste de lexème, en créant des léxèmes parents.
</p>
<p>Principe de fonctionnement:</p>
<ol>
	<li>Le lexer détecte le lexème débutant un parent.</li>
	<li>Il est ajouté à un nouveau lexème parent.</li>
	<li>L'analyse continue avec les règles du parent jusqu'à ce que sa fin soit trouvée ou qu'aucun lexème ne soit trouvé.</li>
	<li>Le lexème parent est ajouté.</li>
	<li>Puis l'analyse continue avec les régles précédant la rencontre du lexème parent.</li>
</ol>

<p>Cela permet de détecter des léxèmes de type:</p>
<ul>
	<li>chaines de caractères compris entre des guillements</li>
	<li>commentaires multiligne de type (/* */)</li>
	<li>commentaires sur une ligne de type (//)</li>
	<li>... code php.</li>
</ul>

<p>Ceci n'a pas forcement de répercution sur l'analyse syntaxique...</p>


<h3>Les Automates Finis Déterministes</h3>
<p>Ils doivent-être précalculés :</p>
<ol>
	<li>Chaque <a href="AFD.generator.htm">ER est transformée en AFD</a></li>
	<li>Ces <a href="AFD.aggregator.htm">AFDs sont aggrégés entre eux</a> afin d'en obtenir plus qu'un !</li>
</ol>
<p>Malheureusement il est parfois préférable d'en utiliser plusieurs à la place :</p>
<ul>
	<li>La taille de l'automate résultat pouvant-être trop volumineuse, </li>
	<li>ou sa création prennant beaucoup trop de temps.</li>
</ul>
<p>L'analyse lexicale se fait ensuite avec un ou plusieurs AFD :</p>
<ul>
	<li>Performance (calcul) = 1 AFD.</li>
	<li>Maintenance / Evolution = Plusieurs AFDs.</li>
	<li>Performance téléchargement = Fonction de la taille des AFDs.</li>
</ul>
<p>Un mini langage a été créé pour <a href="LexerAutomaton.module.generator.htm">créer des modules pour le Lexer Automaton</a>.</p>




<script src="js/framework.js"></script>
<script src="js/lexer.automaton.js"></script>
<script src="js/lexer.automaton.modules.js"></script>
<script>
_('eTextScanned,eResult')
var setElementTitle =function(o){
	return  ' value:\u25B6'+o.value+'\u25C0\n'
		+ JSON.stringify( o, 'token,parentToken,css,index,lineStart,lineEnd'.split(','), " " )
			.str_replace('"', '')
			.slice(2,-1)
			.split(',')
			.join('')
	}
var Lexeme =function( o ){
	var sToken = o.token
	, e = document.createElement( sToken )
	, sValue = o.value
	e.oValue = o
	e.title = setElementTitle( o )
		// sToken +\n\u25B6+ sValue +\u25C0
	if( sValue ) e.innerHTML = sValue.str_replace( ['&','<','>'], ['&amp;','&lt;','&gt;'])
	e.className = 'myNode'
	if( o.css ) e.className += ' '+ o.css
	return e
	}
var scan =function(){
	eResult.innerHTML = ''
	eResult.appendChild( AutomatonLexer( eTextScanned.value, 'TXT' ))
	}
scan()
eTextScanned.onkeyup = scan
</script>
	</body>
</html>